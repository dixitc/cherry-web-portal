
CRITICAL :
	- pass country code during register
	- separate out singleMomentreducer (to better handle moment level actions)

PROGRESS :
    -prev = hooking up verificationId (done , need to set and get user when token is present (refresh user details))
    -current = setup memories view (https://github.com/eiriklv/react-masonry-component) [MASONRY_COMPONENT] (doing) look for alternatives
	-next = (MemoriesView(handles fetching memories) , MemoryView(handles clicking on options , memory , redirection to momentsView) , MomentsView (handles fetching and displaying moments), MomentView(handle like etc))
		-separate authenticated component from MemoriesView (done partially , its the default /memories route need to change this)
		-populate momentsView (need to define state shape) (done partially state shape not finalized , need to normalize)
		-setup initial profile (name and image) consider normalizing response

	-then = clean up all pending thingsToDo (FRIDAY)

thingsToDo  :
	- use npm-shrinkwrap (to lock dependencies , avoid dependency hell)
	- setup testing environment (done unit-tests mocha , karma , , e2e testing nightwatch (pending) http://nightwatchjs.org/)
		- dynamically generating tests for reducers and actions  (https://mochajs.org/#dynamically-generating-tests)
		- consider replacing expect with chai (assertion library choice)
	- login redirect should include the original(authenticated) url that the user was trying to access and redirect accordingly (pending)
	- separate configs for dev and prod (pending)
	- handle all error messages using material TextField and snackbar centrally ?? (implementation decision)
	- use spread operators and es6 syntax wherever possible
	[-] country code number validation (DONE)
	- Testing up to date (50% coverage FRIDAY)


AUTH FLOW :

auth state transition in login

auth : {
	isFetching : false,
	isAuthenticated : false,
	isRegistered : false,
	profile : {}
}

onSubmit => (handleRegistration) => dispatch(registerRequest)

|
V
update state
auth : {
	isFetching : true,
	isAuthenticated : false,
	isRegistered : false
}

        <== {"verificationId" : "_id"} (from server)
onResponse => dispatch(registerSuccess(verificationId))

|
V

update state
auth : {
	isFetching : false,
	isAuthenticated : false,
	isRegistered : true
}

dispatch(verifyRequest(verificationId,OTP))

|
V
update state
We sent you an OTP on this number message to user
auth : {
	isFetching : true,
	isAuthenticated : false,
	isRegistered : true
}
		<== json = {"authToken" : "_token" , "profile" : {profileObject}}
onResponse => dispatch(verifySuccess(json))

|
V
update state

auth : {
	isFetching : false,
	isAuthenticated : true,
	isRegistered : true,
	profile : {profileObject}
}

set LocalStorage  , localStoreage.setItem('cherry_user',auth)
redirectToHome (or the default authenticated route)




FLOW:

USER INPUTS PHONE NUMBER : {
 	DISPATCH ACTION REGISTER_USER(creds) : {
		ON SUCCESS DISPATCH REGISTER_SUCCESS(verificationId) : {
		 	DISPATCH VERIFY_USER(verificationId , otp) : {
				ON SUCCESS DISPATCH VERIFY_SUCCESS(response) : {
					SET authState fields - isAuthnenticated , profile , authoken , save authState to localStorage
				},
				ON FAIL DISPATCH VERIFY_FAIL(errorCode) : {
					HANDLE FAILURE - SHOW UI FEEDBACK TO USER
				}
			}
		},
		ON FAIL DISPATCH REGISTER_FAIL(errorCode) : {
			HANDLE FAILURE - SHOW UI FEEDBACK TO USER
		}
	}
}
